<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Gallery</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #333;
            color: white;
            padding: 10px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .container {
            padding: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .controls input[type="file"],
        .controls button {
            padding: 10px;
            font-size: 1rem;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .preview {
            text-align: center;
            margin-top: 10px;
        }

        .preview img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .gallery-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: grab;
        }

        .gallery-item img {
            width: 100%;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, border-color 0.2s;
        }

        .gallery-item img.current-photo {
            border: 4px solid red;
        }

        .gallery-item button {
            margin-top: 10px;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .send-btn {
            background-color: blue;
            color: white;
        }

        .send-btn:hover {
            background-color: darkblue;
        }

        .delete-btn {
            background-color: red;
            color: white;
        }

        .delete-btn:hover {
            background-color: darkred;
        }

        .dragging {
            opacity: 0.5;
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s;
        }

        #modal.active {
            visibility: visible;
            opacity: 1;
        }

        #modal-content {
            background: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        #spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #ddd;
            border-top: 5px solid blue;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .current-display {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .current-photo-container {
            text-align: center;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #current-display-image {
            max-width: 300px;
            max-height: 200px;
            object-fit: contain;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        #no-photo-message {
            color: #666;
            font-style: italic;
        }

        .parameters-box {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .parameter-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .parameter-group label {
            font-weight: bold;
            min-width: 120px;
        }

        .parameter-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            cursor: pointer;
        }

        .parameter-group select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .parameter-group input[type="text"],
        .parameter-group input[type="number"],
        .parameter-group input[type="password"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 14px;
            flex: 1;
            max-width: 200px;
        }

        .parameters-box h4,
        .current-display h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
        }

        .mqtt-save-btn {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .mqtt-save-btn:hover {
            background-color: #45a049;
        }

        .action-button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            flex: 1;
        }

        .action-button:hover {
            background-color: #45a049;
        }

        .action-button:active {
            background-color: #3d8b40;
        }

        .display-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .parameter-group textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            resize: vertical;
        }

        .action-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .action-btn:hover {
            background-color: #45a049;
        }

        .generated-images-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .generated-image-wrapper {
            position: relative;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
        }

        .generated-image-wrapper.selected {
            border-color: #4CAF50;
        }

        .generated-image-wrapper img {
            width: 100%;
            height: auto;
            border-radius: 3px;
        }

        .generated-image-wrapper::before {
            content: '';
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: transparent;
            display: none;
        }

        .generated-image-wrapper.selected::before {
            display: block;
            background-color: #4CAF50;
        }

        /* Style for disabled option */
        select option:disabled {
            color: #999;
            font-style: italic;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .color-palette {
            display: flex;
            gap: 8px;
            margin-top: 5px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .generated-image-wrapper.auto-selected {
            border: 2px solid #4CAF50;
            cursor: default;
        }

        .generated-image-wrapper.auto-selected:hover {
            transform: none;
        }

        /* Style for the dropdown */
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }

        /* Style for option groups */
        optgroup {
            font-weight: bold;
            color: #666;
        }

        /* Style for options */
        option {
            padding: 4px;
            color: #333;
        }

        .hidden {
            display: none;
        }

        .settings-section {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .settings-section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .settings-grid {
            display: grid;
            gap: 20px;
        }

        .settings-form {
            display: grid;
            gap: 15px;
            max-width: 500px;
        }

        .setting-item {
            display: grid;
            grid-template-columns: 1fr 2fr;
            align-items: center;
            gap: 10px;
        }

        .setting-item label {
            font-weight: bold;
            color: #555;
        }

        .setting-item input[type="text"],
        .setting-item input[type="password"],
        .setting-item input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        .primary-button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .primary-button:hover {
            background-color: #45a049;
        }

        .setting-item:last-child {
            grid-column: 1 / -1;
            justify-content: end;
        }

        .accordion {
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
        }

        .accordion-item {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }

        .accordion-header {
            padding: 12px 15px;
            background-color: #f8f9fa;
            cursor: pointer;
            font-weight: 600;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .accordion-header:hover {
            background-color: #f1f1f1;
        }

        .accordion-header::after {
            content: '▼';
            font-size: 0.8em;
            color: #666;
            transition: transform 0.2s;
        }

        .accordion-item.active .accordion-header::after {
            transform: rotate(180deg);
        }

        .accordion-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }

        .accordion-item.active .accordion-content {
            padding: 15px;
            max-height: 1000px; /* Adjust based on content size */
            border-top: 1px solid #eee;
        }

        .battery-status {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            z-index: 1000;
        }

        .battery-icon {
            width: 24px;
            height: 12px;
            border: 2px solid #333;
            border-radius: 3px;
            position: relative;
            display: inline-block;
        }

        .battery-icon::after {
            content: '';
            position: absolute;
            right: -4px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 6px;
            background: #333;
            border-radius: 0 2px 2px 0;
        }

        .battery-level {
            position: absolute;
            left: 1px;
            top: 1px;
            bottom: 1px;
            background: #4CAF50;
            border-radius: 1px;
            transition: width 0.3s;
        }

        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        #scheduleOptions.disabled input,
        #scheduleOptions.disabled select {
            background-color: #f0f0f0;
            cursor: not-allowed;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .reset-button {
            padding: 5px 15px;
            border-radius: 4px;
            background-color: #f44336;
            color: white;
            border: none;
            cursor: pointer;
        }

        .battery-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
        }

        .battery-outline {
            width: 50px;
            height: 24px;
            border: 2px solid #fff;
            border-radius: 3px;
            position: relative;
            padding: 1px;
        }

        .battery-outline:after {
            content: '';
            position: absolute;
            right: -5px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 10px;
            background: #fff;
            border-radius: 0 2px 2px 0;
        }

        .battery-level {
            height: 100%;
            background: #4CAF50;
            border-radius: 1px;
            transition: width 0.3s ease;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .reset-btn {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .reset-btn:hover {
            background-color: #cc0000;
        }

        /* Add task list styling */
        .scheduled-task {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 50px;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .delete-task-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .delete-task-btn:hover {
            background: #cc0000;
        }

        /* Unified Accordion Styles */
        .accordion-item {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }

        .accordion-header {
            padding: 12px 15px;
            background-color: #f8f9fa;
            cursor: pointer;
            font-weight: 600;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .accordion-header:hover {
            background-color: #f1f1f1;
        }

        .accordion-header::after {
            content: '▼';
            font-size: 0.8em;
            color: #666;
            transition: transform 0.2s;
        }

        .accordion-item.active .accordion-header::after {
            transform: rotate(180deg);
        }

        .accordion-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }

        .accordion-item.active .accordion-content {
            padding: 15px;
            max-height: 1000px; /* Adjust based on content size */
            border-top: 1px solid #eee;
        }

        /* Update existing sections to use accordion classes */
        .display-settings,
        .home-assistant-settings,
        .sftp-settings {
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        /* Convert existing sections to accordion structure */
    </style>
    <!-- Add cache-busting version to prevent caching -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
</head>
<body>
    <header>
        <div class="header-title">Photo Gallery</div>
        <div class="header-controls">
            <div class="battery-indicator">
                <div class="battery-outline">
                    <div id="batteryLevel" class="battery-level"></div>
                </div>
                <span id="batteryPercentage">--.--%</span>
            </div>
            <button id="resetButton" class="reset-btn">Reset</button>
        </div>
    </header>
    <div class="container">
        <!-- Replace the existing sections with this accordion structure -->
        <div class="accordion">
            <!-- Display Parameters Section -->
            <div class="accordion-item">
                <div class="accordion-header">Display Settings</div>
                <div class="accordion-content">
                    <div class="settings-section">
                        <div class="settings-grid">
                            <div class="parameter-group">
                                <label for="changeInterval">Change every:</label>
                                <select id="changeInterval" onchange="updateChangeInterval()">
                                    <option value="0">Never</option>
                                    <option value="1">1 minute</option>
                                    <option value="30">30 minutes</option>
                                    <option value="60">1 hour</option>
                                    <option value="120">2 hours</option>
                                    <option value="360">6 hours</option>
                                    <option value="1440">24 hours</option>
                                </select>
                            </div>
                            <div class="parameter-group">
                                <label for="rotation">Orientation:</label>
                                <select id="rotation" onchange="updateRotation()">
                                    <option value="portrait">Portrait</option>
                                    <option value="landscape">Landscape</option>
                                </select>
                            </div>
                            <div class="parameter-group display-controls">
                                <button onclick="rotateDisplay()" class="action-button">
                                    Rotate 90°
                                </button>
                                <button onclick="flipDisplay()" class="action-button">
                                    Flip 180°
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Home Assistant Parameters Section -->
            <div class="accordion-item">
                <div class="accordion-header">Home Assistant</div>
                <div class="accordion-content">
                    <div class="settings-section">
                        <div class="settings-grid">
                            <div class="parameter-group">
                                <label for="deviceName">Device Name:</label>
                                <input type="text" id="deviceName" placeholder="eInk Frame">
                            </div>
                            <div class="parameter-group">
                                <label for="mqttBroker">MQTT Broker:</label>
                                <input type="text" id="mqttBroker" placeholder="e.g., 192.168.1.100">
                            </div>
                            <div class="parameter-group">
                                <label for="mqttPort">MQTT Port:</label>
                                <input type="number" id="mqttPort" value="1883">
                            </div>
                            <div class="parameter-group">
                                <label for="mqttUser">MQTT Username:</label>
                                <input type="text" id="mqttUser">
                            </div>
                            <div class="parameter-group">
                                <label for="mqttPassword">MQTT Password:</label>
                                <input type="text" id="mqttPassword">
                            </div>
                            <div class="parameter-group">
                                <label for="mqttEnabled">Enable MQTT:</label>
                                <input type="checkbox" id="mqttEnabled" name="mqttEnabled">
                            </div>
                            <div class="parameter-group">
                                <button onclick="updateMQTTSettings()" class="mqtt-save-btn">Save MQTT Settings</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SFTP Settings Section -->
            <div class="accordion-item">
                <div class="accordion-header">SFTP Settings</div>
                <div class="accordion-content">
                    <div class="settings-section">
                        <div class="settings-grid">
                            <form id="sftpSettingsForm" class="settings-form">
                                <div class="setting-item">
                                    <label for="sftpEnabled">Enable SFTP Server:</label>
                                    <input type="checkbox" id="sftpEnabled" name="sftpEnabled">
                                </div>
                                
                                <div class="setting-item">
                                    <label for="sftpPort">Port:</label>
                                    <input type="number" id="sftpPort" name="sftpPort" value="2222" min="1" max="65535">
                                </div>
                                
                                <div class="setting-item">
                                    <label for="sftpUsername">Username:</label>
                                    <input type="text" id="sftpUsername" name="sftpUsername">
                                </div>
                                
                                <div class="setting-item">
                                    <label for="sftpPassword">Password:</label>
                                    <input type="password" id="sftpPassword" name="sftpPassword">
                                </div>
                                
                                <div class="setting-item">
                                    <button type="submit" class="primary-button">Save SFTP Settings</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schedule Settings Section -->
            <div class="accordion-item">
                <div class="accordion-header">Schedule Settings</div>
                <div class="accordion-content">
                    <form id="scheduleForm">
                        <div class="parameter-group">
                            <label for="scheduleEnabled">Enable Scheduling:</label>
                            <input type="checkbox" id="scheduleEnabled" name="scheduleEnabled" onchange="toggleScheduleOptions()">
                        </div>
                        
                        <div id="scheduleOptions">
                            <div class="parameter-group">
                                <label for="scheduleType">Schedule Type:</label>
                                <select id="scheduleType" name="scheduleType">
                                    <option value="interval">Interval</option>
                                    <option value="time">Daily Time</option>
                                </select>
                            </div>
                            
                            <div id="intervalSettings" class="parameter-group">
                                <label for="intervalMinutes">Change Interval (minutes):</label>
                                <input type="number" id="intervalMinutes" name="intervalMinutes" min="0">
                            </div>
                            
                            <div id="timeSettings" class="parameter-group" style="display: none;">
                                <label for="dailyTime">Daily Change Time:</label>
                                <input type="time" id="dailyTime" name="dailyTime">
                            </div>
                            
                            <div class="parameter-group">
                                <label for="timezone">Timezone:</label>
                                <select id="timezone" name="timezone">
                                    <option value="UTC">UTC (Default)</option>
                                </select>
                            </div>

                        </div>
                        
                        <!-- Add scheduled tasks list -->
                        <div class="parameter-group" style="margin-top: 20px;">
                            <h4>Scheduled Tasks</h4>
                            <div id="scheduledTasksList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
                                <div class="task-list-header" style="display: grid; grid-template-columns: 2fr 1fr 1fr 50px; gap: 10px; margin-bottom: 10px; font-weight: bold;">
                                    <div>Job Type</div>
                                    <div>Next Run</div>
                                    <div>Interval</div>
                                    <div></div>
                                </div>
                                <div id="scheduledTasks"></div>
                            </div>
                        </div>

                        <button type="submit">Save Schedule</button>
                    </form>
                </div>
            </div>

            <!-- Sleep Settings Section -->
            <div class="accordion-item">
                <div class="accordion-header">Sleep Settings</div>
                <div class="accordion-content">
                    <div class="parameter-group">
                        <label for="sleepWindow">Auto-Sleep After Inactivity:</label>
                        <select id="sleepWindow" name="sleepWindow">
                            <option value="0">Never</option>
                            <option value="30">30 minutes</option>
                            <option value="60">1 hour</option>
                            <option value="180">3 hours</option>
                            <option value="360">6 hours</option>
                            <option value="720">12 hours</option>
                            <option value="1440">24 hours</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="parameters-box">
            <h4>Image Generation Parameters</h4>
            <div class="parameter-group">
                <label for="imageService">Image Generation Service:</label>
                <select id="imageService" onchange="updateApiKeyPlaceholder()">
                    <option value="stability">Stability AI</option>
                    <option value="dalle">DALL-E</option>
                </select>
            </div>
            <div class="parameter-group">
                <label for="modelName">Model Name:</label>
                <input type="text" id="modelName" placeholder="Enter model name">
            </div>
            <div class="parameter-group">
                <label for="apiKey">API Key:</label>
                <input type="text" id="apiKey" placeholder="Enter API key">
            </div>
            <div class="parameter-group">
                <div style="text-align: left;">
                    <input type="checkbox" id="optimizeColors" checked>
                    <label for="optimizeColors">Optimize for eInk Display Colors</label>
                </div>
            </div>
            <div class="parameter-group">
                <label for="style">Image Style:</label>
                <select id="style">
                    <option value="">No specific style</option>
                    <!-- Traditional Art Styles -->
                    <optgroup label="Classical Art">
                        <option value="Renaissance">Renaissance</option>
                        <option value="Baroque">Baroque</option>
                        <option value="Impressionism">Impressionism</option>
                        <option value="Cubism">Cubism</option>
                        <option value="Surrealism">Surrealism</option>
                        <option value="Art Deco">Art Deco</option>
                        <option value="Pop Art">Pop Art</option>
                        <option value="Abstract Expressionism">Abstract Expressionism</option>
                        <option value="Futurism">Futurism</option>
                    </optgroup>
                    
                    <!-- Cultural Art Styles -->
                    <optgroup label="Cultural Art">
                        <option value="Japanese Ukiyo-e">Japanese Ukiyo-e</option>
                        <option value="Islamic Geometric Art">Islamic Geometric Art</option>
                        <option value="African Tribal Art">African Tribal Art</option>
                        <option value="Aztec/Mayan Art">Aztec/Mayan Art</option>
                        <option value="Native American Art">Native American Art</option>
                        <option value="Indian Miniature Paintings">Indian Miniature Paintings</option>
                    </optgroup>
                    
                    <!-- Traditional Media -->
                    <optgroup label="Traditional Media">
                        <option value="Oil Painting">Oil Painting</option>
                        <option value="Watercolor">Watercolor</option>
                        <option value="Charcoal Drawing">Charcoal Drawing</option>
                        <option value="Ink Sketch">Ink Sketch</option>
                        <option value="Stained Glass">Stained Glass</option>
                        <option value="Papercut">Papercut</option>
                    </optgroup>
                    
                    <!-- Digital & Modern -->
                    <optgroup label="Digital & Modern">
                        <option value="Digital Art">Digital Art</option>
                        <option value="Pixel Art">Pixel Art</option>
                        <option value="Collage">Collage</option>
                        <option value="Flat Design">Flat Design</option>
                        <option value="Isometric">Isometric</option>
                        <option value="Low Poly">Low Poly</option>
                        <option value="Typography Art">Typography Art</option>
                        <option value="Line Art">Line Art</option>
                    </optgroup>
                    
                    <!-- Genre Styles -->
                    <optgroup label="Genre Styles">
                        <option value="Steampunk">Steampunk</option>
                        <option value="Cyberpunk">Cyberpunk</option>
                        <option value="Medieval Fantasy">Medieval Fantasy</option>
                        <option value="Space Opera">Space Opera</option>
                        <option value="Dark Fantasy">Dark Fantasy</option>
                        <option value="Post-Apocalyptic">Post-Apocalyptic</option>
                    </optgroup>
                    
                    <!-- Photography & Film -->
                    <optgroup label="Photography & Film">
                        <option value="Monochrome">Monochrome</option>
                        <option value="Black and White Photography">Black and White Photography</option>
                        <option value="Cinematic">Cinematic</option>
                        <option value="HDR">HDR (High Dynamic Range)</option>
                        <option value="Vintage Film">Vintage Film</option>
                        <option value="Macro Photography">Macro Photography</option>
                    </optgroup>
                    
                    <!-- Illustration -->
                    <optgroup label="Illustration">
                        <option value="Cartoon/Comic Style">Cartoon/Comic Style</option>
                        <option value="Chibi Style">Chibi Style</option>
                        <option value="Storybook Illustration">Storybook Illustration</option>
                    </optgroup>
                </select>
            </div>
            <div class="parameter-group">
                <label for="imagePrompt">Image Prompt:</label>
                <textarea id="imagePrompt" rows="3" placeholder="Describe the image you want to generate..."></textarea>
            </div>
            <div class="parameter-group">
                <label for="orientation">Image Orientation:</label>
                <select id="orientation">
                    <option value="portrait">Portrait (1024x1792)</option>
                    <option value="landscape">Landscape (1792x1024)</option>
                    <option value="square">Square (1024x1024)</option>
                </select>
            </div>
            <button id="generateButton" class="action-btn">Generate Images</button>
            
            <div id="generatedImages" class="generated-images-container">
                <!-- Generated images will be displayed here -->
            </div>
            
            <button id="saveSelectedButton" class="action-btn" style="display: none;">Save Selected Images</button>
        </div>

        <div class="controls">
            <h4>Upload Photo:</h4>
            <input type="file" id="uploadInput" accept=".bmp,.jpg,.jpeg,.png">
            {% if unsplash_api_key %}
            <button type="button" class="action-button" onclick="showUnsplashModal()">
                Add from Unsplash
            </button>
            {% endif %}
            {% if pixabay_api_key %}
            <button type="button" class="action-button" onclick="showPixabayModal()">
                Add from Pixabay
            </button>
            {% endif %}
        </div>
        <div class="preview" id="preview-container">
            <img id="preview-image" src="#" alt="Preview" style="display: none;">
            <button onclick="uploadPhoto()">Upload Photo</button>
        </div>
        <div class="current-display" id="current-display">
            <h4>Currently on eInk Display:</h4>
            <div class="current-photo-container">
                <img id="current-display-image" src="#" alt="No photo currently displayed" style="display: none;">
                <p id="no-photo-message" style="display: block;">No photo currently displayed</p>
            </div>
        </div>
        <div class="gallery" id="gallery"></div>
        <button onclick="saveOrder()" style="display: block; margin: 20px auto;">Save Order</button>
    </div>

    <!-- Modal -->
    <div id="modal">
        <div id="modal-content">
            <h3 id="modal-text">Loading...</h3>
            <div id="spinner"></div>
        </div>
    </div>

    <!-- Stock Photo Modal (used for both Unsplash and Pixabay) -->
    <div id="stockPhotoModal" class="modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; overflow: auto;">
        <div style="background-color: white; margin: 10% auto; padding: 20px; width: 80%; max-width: 800px; border-radius: 8px; position: relative;">
            <span style="position: absolute; top: 10px; right: 20px; font-size: 24px; cursor: pointer;" onclick="hideStockPhotoModal()">&times;</span>
            <h3 id="stockModalTitle">Search Photos</h3>
            
            <div style="margin: 20px 0;">
                <input type="text" id="stockSearchInput" placeholder="Search for photos..." style="width: 70%; padding: 10px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <button onclick="searchStockPhotos()" style="padding: 10px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Search</button>
            </div>
            
            <div id="stockPhotoResults" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 20px;">
                <!-- Photos will be loaded here -->
            </div>
            
            <div id="stockPhotoLoader" style="text-align: center; margin: 20px 0; display: none;">
                <div style="width: 40px; height: 40px; border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; margin: 0 auto; animation: spin 2s linear infinite;"></div>
                <p>Loading photos...</p>
            </div>
            
            <div style="margin-top: 20px; text-align: right;">
                <button onclick="hideStockPhotoModal()" style="padding: 8px 15px; background-color: #f44336; color: white; border: none; border-radius: 4px; margin-right: 10px; cursor: pointer;">Cancel</button>
                <button id="addSelectedStockPhotosBtn" onclick="addSelectedStockPhotos()" style="padding: 8px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Add Selected</button>
            </div>
        </div>
    </div>

    <script>
        // Add version number to prevent caching
        const version = '{{ version }}';
        console.log('Template version:', version);
        
        let draggedItem = null;

        // Define all functions first
        async function saveOrder() {
            const gallery = document.getElementById('gallery');
            const items = gallery.querySelectorAll('.gallery-item');
            const order = Array.from(items).map(item => item.dataset.filename);
            
            console.log('Saving new order:', order);
            
            try {
                const response = await fetch('/api/photos/reorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ order: order })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to save photo order:', errorData);
                } else {
                    const result = await response.json();
                    console.log('Order saved successfully:', result);
                }
            } catch (e) {
                console.error('Error saving photo order:', e);
            }
        }

        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
        }

        async function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedItem = null;
            await saveOrder();
        }

        function handleDragOver(e) {
            e.preventDefault();
            const gallery = document.getElementById('gallery');
            const afterElement = getDragAfterElement(gallery, e.clientY);
            const draggable = document.querySelector('.dragging');
            
            if (draggable) {
                if (afterElement == null) {
                    gallery.appendChild(draggable);
                } else {
                    gallery.insertBefore(draggable, afterElement);
                }
            }
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.gallery-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Then define loadPhotos which uses these functions
        async function loadPhotos() {
            const response = await fetch('/api/photos');
            const { photos, current_photo } = await response.json();
            
            // Update current display section
            const currentDisplayImage = document.getElementById('current-display-image');
            const noPhotoMessage = document.getElementById('no-photo-message');
            
            if (current_photo) {
                currentDisplayImage.src = `/photos/${current_photo}`;
                currentDisplayImage.style.display = 'block';
                noPhotoMessage.style.display = 'none';
            } else {
                currentDisplayImage.style.display = 'none';
                noPhotoMessage.style.display = 'block';
            }

            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            // Add dragover event to the gallery container
            gallery.addEventListener('dragover', handleDragOver);

            photos.forEach(photo => {
                const wrapper = document.createElement('div');
                wrapper.classList.add('gallery-item');
                wrapper.draggable = true;
                wrapper.dataset.filename = photo;

                const img = document.createElement('img');
                img.src = `/photos/${photo}`;
                img.alt = photo;
                if (photo === current_photo) {
                    img.classList.add('current-photo');
                }

                const sendButton = document.createElement('button');
                sendButton.innerText = "Send to eInk";
                sendButton.classList.add('send-btn');
                sendButton.onclick = () => sendToEink(photo);

                const deleteButton = document.createElement('button');
                deleteButton.innerText = "Delete";
                deleteButton.classList.add('delete-btn');
                deleteButton.onclick = () => deletePhoto(photo);

                wrapper.appendChild(img);
                wrapper.appendChild(sendButton);
                wrapper.appendChild(deleteButton);
                gallery.appendChild(wrapper);

                // Add drag events to each item
                wrapper.addEventListener('dragstart', handleDragStart);
                wrapper.addEventListener('dragend', handleDragEnd);
            });
        }

        async function uploadPhoto() {
            const fileInput = document.getElementById('uploadInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file to upload.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/photos/upload', {
                    method: 'POST',
                    body: formData,
                });

                if (response.ok) {
                    alert('Photo uploaded successfully!');
                    fileInput.value = ''; // Clear the input
                    loadPhotos(); // Reload gallery
                } else {
                    const errorData = await response.json();
                    alert(`Upload failed: ${errorData.error}`);
                }
            } catch (err) {
                console.error('Error uploading photo:', err);
                alert('An error occurred during upload.');
            }
        }

        async function sendToEink(photo) {
            try {
                showModal('Loading Photo to eInk Display...');
                const response = await fetch('/api/photos/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ photo })
                });

                if (response.ok) {
                    const result = await response.json();
                    await loadPhotos(); // This will update both the gallery and current display
                    alert('Photo sent to eInk display!');
                } else {
                    const result = await response.json();
                    alert(result.error || 'Failed to send photo.');
                }
            } catch (e) {
                alert('Error communicating with the server.');
            } finally {
                hideModal();
            }
        }

        async function deletePhoto(photo) {
            try {
                const response = await fetch(`/api/photos/delete/${photo}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    alert('Photo deleted successfully!');
                    loadPhotos();
                } else {
                    alert('Failed to delete photo.');
                }
            } catch (e) {
                alert('Error communicating with the server.');
            }
        }

        function showPreview(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewImage = document.getElementById('preview-image');
                    previewImage.src = e.target.result;
                    previewImage.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        }

        document.getElementById('uploadInput').addEventListener('change', showPreview);

        // Add updateChangeInterval function
        async function updateChangeInterval() {
            const interval = parseInt(document.getElementById('changeInterval').value);
            console.log('Setting new change interval:', interval);
            
            try {
                const response = await fetch('/api/settings/interval', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ interval: interval })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to update interval:', errorData);
                    alert('Failed to update change interval');
                } else {
                    const result = await response.json();
                    console.log('Interval updated successfully:', result);
                }
            } catch (e) {
                console.error('Error updating interval:', e);
                alert('Error updating change interval');
            }
        }

        // Add new function to handle rotation changes
        async function updateRotation() {
            const rotation = document.getElementById('rotation').value;
            console.log('Setting new rotation:', rotation);
            
            try {
                const response = await fetch('/api/settings/rotation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ rotation: rotation })
                });

                const result = await response.json();
                
                if (!response.ok) {
                    console.error('Failed to update rotation:', result);
                    alert('Failed to update rotation: ' + (result.error || 'Unknown error'));
                } else {
                    console.log('Rotation updated successfully:', result);
                    // Reload current photo to apply new rotation
                    await loadPhotos();
                }
            } catch (e) {
                console.error('Error updating rotation:', e);
                alert('Error updating rotation: ' + e.message);
            }
        }

        async function updateMQTTSettings() {
            const settings = {
                device_name: document.getElementById('deviceName').value || 'eInk Frame',
                broker: document.getElementById('mqttBroker').value,
                port: parseInt(document.getElementById('mqttPort').value),
                username: document.getElementById('mqttUser').value,
                password: document.getElementById('mqttPassword').value,
                enabled: document.getElementById('mqttEnabled').checked
            };

            try {
                const response = await fetch('/api/settings/mqtt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });

                let result;
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.includes("application/json")) {
                    result = await response.json();
                } else {
                    // If not JSON, get the text and create an error object
                    const text = await response.text();
                    throw new Error(`Server returned non-JSON response: ${text}`);
                }
                
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to update MQTT settings');
                }

                console.log('MQTT settings updated successfully:', result);
                alert('MQTT settings updated successfully');
                
            } catch (e) {
                console.error('Error updating MQTT settings:', e);
                alert('Error updating MQTT settings: ' + e.message);
            }
        }

        // Add debug function
        function debugSettings() {
            fetch('/api/settings/debug')
                .then(response => response.json())
                .then(settings => {
                    console.log('Current settings:', settings);
                })
                .catch(error => {
                    console.error('Error getting debug settings:', error);
                });
        } 

        // Update loadSettings with debug logging
        function loadSettings() {
            try {
                fetch('/api/settings')
                    .then(response => response.json())
                    .then(settings => {
                        console.log('Loading settings (API keys masked):', {
                            ...settings,
                            dalle_api_key: settings.dalle_api_key ? '[PRESENT]' : '[EMPTY]',
                            stability_api_key: settings.stability_api_key ? '[PRESENT]' : '[EMPTY]'
                        });
                        
                        // Set service to saved default or fallback to 'stability'
                        const serviceSelect = document.getElementById('imageService');
                        const service = settings.default_service || 'stability';
                        serviceSelect.value = service;
                        
                        // Load the appropriate API key based on the selected service
                        const apiKeyInput = document.getElementById('apiKey');
                        if (service === 'dalle') {
                            apiKeyInput.value = settings.dalle_api_key || '';
                        } else {
                            apiKeyInput.value = settings.stability_api_key || '';
                        }
                        
                        // Load saved model names with defaults
                        const modelInput = document.getElementById('modelName');
                        const promptInput = document.getElementById('imagePrompt');
                        
                        // Set model name and API key based on selected service
                        if (service === 'dalle') {
                            modelInput.value = settings.dalle_model || 'dall-e-3';
                            modelInput.placeholder = 'e.g., dall-e-3';
                        } else {
                            modelInput.value = settings.stability_model || 'ultra';
                            modelInput.placeholder = 'e.g., ultra';
                        }
                        
                        // Load saved prompt if it exists
                        if (settings.last_prompt) {
                            promptInput.value = settings.last_prompt;
                        }
                        
                        // Load other settings if they exist
                        if (settings.mqtt) {
                            document.getElementById('mqttBroker').value = settings.mqtt.broker || '';
                            document.getElementById('mqttPort').value = settings.mqtt.port || 1883;
                            document.getElementById('mqttUser').value = settings.mqtt.username || '';
                            document.getElementById('mqttPassword').value = settings.mqtt.password || '';
                            document.getElementById('deviceName').value = settings.mqtt.device_name || 'eInk Frame';
                            document.getElementById('mqttEnabled').checked = settings.mqtt.enabled || false;
                        }

                        if (settings.sleep_window !== undefined) {
                            document.getElementById('sleepWindow').value = settings.sleep_window.toString();
                        }
                    })
                    .catch(error => {
                        console.error('Error loading settings:', error);
                    });
            } catch (error) {
                console.error('Error in loadSettings:', error);
            }
        }

        // Call debugSettings on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            debugSettings();
        });

        async function saveImagenSettings() {
            const apiKey = document.getElementById('apiKey').value;
            
            try {
                const response = await fetch('/api/settings/imagen', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        api_key: apiKey
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save API key');
                }
            } catch (error) {
                console.error('Error saving API key:', error);
                alert('Error saving API key: ' + error.message);
            }
        }

        // Update the initialization to load settings
        async function initialize() {
            await loadSettings();
            await loadPhotos();
        }

        // Finally, initialize the page
        initialize();

        function rotateDisplay() {
            const modal = document.getElementById('modal');
            modal.classList.add('active');

            fetch('/rotate_display', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                modal.classList.remove('active');
                if (data.error) {
                    alert('Error rotating display: ' + data.error);
                } else {
                    // Optional: show success message
                    alert('Display rotation updated');
                }
            })
            .catch(error => {
                modal.classList.remove('active');
                alert('Error rotating display: ' + error);
            });
        }

        function flipDisplay() {
            const modal = document.getElementById('modal');
            modal.classList.add('active');

            fetch('/flip_display', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                modal.classList.remove('active');
                if (data.error) {
                    alert('Error flipping display: ' + data.error);
                } else {
                    // Optional: show success message
                    alert('Display flip updated');
                }
            })
            .catch(error => {
                modal.classList.remove('active');
                alert('Error flipping display: ' + error);
            });
        }

        function updateApiKeyPlaceholder() {
            const service = document.getElementById('imageService').value;
            const apiKeyInput = document.getElementById('apiKey');
            const modelInput = document.getElementById('modelName');
            
            // Load saved settings for the selected service
            fetch('/api/settings')
                .then(response => response.json())
                .then(settings => {
                    if (service === 'dalle') {
                        modelInput.value = settings.dalle_model || 'dall-e-3';
                        modelInput.placeholder = 'e.g., dall-e-3';
                        apiKeyInput.value = settings.dalle_api_key || '';
                        apiKeyInput.placeholder = 'Enter your OpenAI API key';
                    } else {
                        modelInput.value = settings.stability_model || 'ultra';
                        modelInput.placeholder = 'e.g., ultra';
                        apiKeyInput.value = settings.stability_api_key || '';
                        apiKeyInput.placeholder = 'Enter your Stability AI API key';
                    }
                    console.log(`Loaded model name for ${service}: ${modelInput.value}`);
                })
                .catch(error => {
                    console.error('Error loading settings:', error);
                });
        }

        function saveModelName() {
            const service = document.getElementById('imageService').value;
            const modelName = document.getElementById('modelName').value;
            
            console.log(`Saving model name for service ${service}: ${modelName}`);
            
            fetch('/api/settings/model', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    service: service,
                    model_name: modelName
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('Error saving model name:', data.error);
                    alert('Error saving model name: ' + data.error);
                } else {
                    console.log('Model name saved successfully:', data);
                }
            })
            .catch(error => {
                console.error('Error saving model name:', error);
                alert('Error saving model name: ' + error.message);
            });
        }

        // Add event listener for model name changes
        document.getElementById('modelName').addEventListener('change', saveModelName);

        // Update the API key saving functionality
        function saveApiKey() {
            const service = document.getElementById('imageService').value;
            const apiKey = document.getElementById('apiKey').value;
            
            console.log(`Saving API key for service: ${service}`);
            
            const data = {};
            if (service === 'dalle') {
                data.dalle_api_key = apiKey;
            } else if (service === 'stability') {
                data.stability_api_key = apiKey;
            }
            
            fetch('/api/settings/api-keys', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('Error saving API key:', data.error);
                    alert('Error saving API key: ' + data.error);
                } else {
                    console.log('API key saved successfully for:', data.updated_services);
                }
            })
            .catch(error => {
                console.error('Error saving API key:', error);
                alert('Error saving API key: ' + error.message);
            });
        }

        // Add event listener for API key changes
        document.getElementById('apiKey').addEventListener('change', saveApiKey);

        async function generateImages() {
            const service = document.getElementById('imageService').value;
            const modelName = document.getElementById('modelName').value;
            const apiKey = document.getElementById('apiKey').value;
            const prompt = document.getElementById('imagePrompt').value;
            const optimizeColors = document.getElementById('optimizeColors').checked;
            const style = document.getElementById('style').value;
            const orientation = document.getElementById('orientation').value;
            
            if (!apiKey || !prompt || !modelName) {
                alert('Please provide API key, model name, and prompt');
                return;
            }
            
            // Add color optimization and gradient minimization to the prompt if checked
            let finalPrompt = prompt;
            if (optimizeColors) {
                finalPrompt = `Create an image ${style ? `in the style of ${style}, ` : ''}optimized with these specific requirements:
1. Use only these colors: black, white, yellow, red, blue, and green
2. Fill the entire canvas with the artwork

Here's what to create: ${prompt}`;
            } else {
                finalPrompt = style ? `Create an image in the style of ${style}. Here's what to create: ${prompt}` : prompt;
            }
            
            try {
                showModal('Generating Image... Please Wait...');
                
                const response = await fetch('/api/generate-images', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        service: service,
                        model: modelName,
                        api_key: apiKey,
                        prompt: finalPrompt,
                        optimize_colors: optimizeColors,
                        orientation: orientation
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to generate images');
                }
                
                displayGeneratedImages(data.images);
                document.getElementById('saveSelectedButton').style.display = 'block';
                
            } catch (error) {
                alert('Error generating images: ' + error.message);
            } finally {
                hideModal();
            }
        }

        function displayGeneratedImages(images) {
            const container = document.getElementById('generatedImages');
            container.innerHTML = '';
            
            images.forEach(imageData => {
                const wrapper = document.createElement('div');
                wrapper.className = 'generated-image-wrapper';
                wrapper.dataset.imageData = imageData;
                
                const img = document.createElement('img');
                img.src = `data:image/jpeg;base64,${imageData}`;
                
                wrapper.appendChild(img);
                
                // Only add click handler for selection if there's more than one image
                if (images.length > 1) {
                    wrapper.addEventListener('click', () => {
                        wrapper.classList.toggle('selected');
                    });
                } else {
                    // For single images, no selection UI needed
                    wrapper.classList.add('auto-selected');
                }
                
                container.appendChild(wrapper);
            });
            
            // Update save button text based on number of images
            const saveButton = document.getElementById('saveSelectedButton');
            saveButton.textContent = images.length > 1 ? 'Save Selected Images' : 'Save Image';
            saveButton.style.display = 'block';
        }

        async function saveSelectedImages() {
            const selectedImages = document.querySelectorAll('.generated-image-wrapper.selected');
            const totalImages = document.querySelectorAll('.generated-image-wrapper').length;
            const modal = document.getElementById('modal');
            
            // If there's only one image total, select it automatically
            if (totalImages === 1 && selectedImages.length === 0) {
                const singleImage = document.querySelector('.generated-image-wrapper');
                if (singleImage) {
                    singleImage.classList.add('selected');
                }
            }
            
            // Get the updated selection after potential auto-selection
            const imagesToSave = document.querySelectorAll('.generated-image-wrapper.selected');
            
            if (imagesToSave.length === 0) {
                alert('Please select at least one image to save');
                return;
            }
            
            modal.classList.add('active');
            
            try {
                const response = await fetch('/api/save-generated-images', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        images: Array.from(imagesToSave).map(wrapper => wrapper.dataset.imageData)
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to save images');
                }
                
                alert('Images saved successfully');
                await loadPhotos(); // Refresh the gallery
                
            } catch (error) {
                alert('Error saving images: ' + error.message);
            } finally {
                modal.classList.remove('active');
            }
        }

        document.getElementById('generateButton').addEventListener('click', generateImages);
        document.getElementById('saveSelectedButton').addEventListener('click', saveSelectedImages);

        // Add event listener to load settings when page loads
        document.addEventListener('DOMContentLoaded', loadSettings);

        // Add event listener for API key changes
        document.getElementById('apiKey').addEventListener('change', saveApiKey);

        // Function to show modal with specific text
        function showModal(text) {
            const modal = document.getElementById('modal');
            const modalText = document.getElementById('modal-text');
            modalText.textContent = text;
            modal.classList.add('active');
        }

        // Function to hide modal
        function hideModal() {
            const modal = document.getElementById('modal');
            modal.classList.remove('active');
        }

        // Add these functions to handle Home Assistant prompt sync
        async function loadPromptFromServer() {
            try {
                const response = await fetch('/api/prompt');
                const data = await response.json();
                if (data.prompt) {
                    document.getElementById('imagePrompt').value = data.prompt;
                    saveUserSelections(); // Save to localStorage
                }
            } catch (error) {
                console.error('Error loading prompt:', error);
            }
        }

        async function savePromptToServer(prompt) {
            try {
                await fetch('/api/prompt', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ prompt: prompt })
                });
            } catch (error) {
                console.error('Error saving prompt:', error);
            }
        }

        // Update the SFTP settings form submission handler
        document.getElementById('sftpSettingsForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = {
                sftp: {
                    enabled: document.getElementById('sftpEnabled').checked,
                    port: parseInt(document.getElementById('sftpPort').value) || 2222,
                    username: document.getElementById('sftpUsername').value,
                    password: document.getElementById('sftpPassword').value
                }
            };

            try {
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Settings saved:', result);
                alert('SFTP settings saved successfully');
                // Reload the SFTP server
                await fetch('/api/settings/sftp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData.sftp)
                });
            } catch (error) {
                console.error('Error saving SFTP settings:', error);
                alert('Error saving SFTP settings: ' + error.message);
            }
        });

        // Add this function to load existing SFTP settings
        async function loadSFTPSettings() {
            try {
                const response = await fetch('/api/settings');
                const settings = await response.json();
                
                if (settings.sftp) {
                    document.getElementById('sftpEnabled').checked = settings.sftp.enabled || false;
                    document.getElementById('sftpPort').value = settings.sftp.port || 2222;
                    document.getElementById('sftpUsername').value = settings.sftp.username || '';
                    document.getElementById('sftpPassword').value = settings.sftp.password || '';
                }
            } catch (error) {
                console.error('Error loading SFTP settings:', error);
            }
        }

        // Call loadSFTPSettings when the page loads
        document.addEventListener('DOMContentLoaded', loadSFTPSettings);

        // Initialize accordion functionality
        document.addEventListener('DOMContentLoaded', function() {
            const accordionItems = document.querySelectorAll('.accordion-item');
            
            // Open the first accordion item by default
            accordionItems[0].classList.add('active');
            
            accordionItems.forEach(item => {
                const header = item.querySelector('.accordion-header');
                
                header.addEventListener('click', () => {
                    // Toggle current item
                    const isActive = item.classList.contains('active');
                    
                    // Close all items
                    accordionItems.forEach(otherItem => {
                        otherItem.classList.remove('active');
                    });
                    
                    // If current item wasn't active, open it
                    if (!isActive) {
                        item.classList.add('active');
                    }
                });
            });
        });

        async function updateBatteryStatus() {
            try {
                const response = await fetch('/api/battery');
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error fetching battery status:', data.error);
                    return;
                }

                const levelElement = document.getElementById('batteryLevel');
                const percentageElement = document.getElementById('batteryPercentage');
                
                // Update the battery level visual indicator
                levelElement.style.width = `${data.percentage}%`;
                
                // Update the percentage text
                percentageElement.textContent = `${data.percentage.toFixed(1)}%`;
                
                // Update color based on percentage
                if (data.percentage < 20) {
                    levelElement.style.background = '#ff0000';  // Red for low battery
                } else if (data.percentage < 50) {
                    levelElement.style.background = '#ffa500';  // Orange for medium
                } else {
                    levelElement.style.background = '#4CAF50';  // Green for good
                }
            } catch (error) {
                console.error('Error updating battery status:', error);
            }
        }

        // Update battery status immediately and every 5 minutes
        updateBatteryStatus();

        // Handle schedule type toggle
        document.getElementById('scheduleType').addEventListener('change', function() {
            const intervalSettings = document.getElementById('intervalSettings');
            const timeSettings = document.getElementById('timeSettings');
            
            if (this.value === 'interval') {
                intervalSettings.style.display = 'block';
                timeSettings.style.display = 'none';
            } else {
                intervalSettings.style.display = 'none';
                timeSettings.style.display = 'block';
            }
        });

        // Load schedule settings
        async function loadScheduleSettings() {
            try {
                console.log("Loading schedule settings...");
                const response = await fetch('/api/schedule');
                const settings = await response.json();
                console.log("Received schedule settings:", settings);
                
                document.getElementById('scheduleEnabled').checked = settings.enabled;
                document.getElementById('scheduleType').value = settings.type;
                
                // Only update interval if it exists
                if (settings.interval_minutes !== undefined) {
                    document.getElementById('intervalMinutes').value = settings.interval_minutes;
                }
                
                // Only update daily time if it exists
                if (settings.daily_time) {
                    document.getElementById('dailyTime').value = settings.daily_time;
                }
                
                document.getElementById('timezone').value = settings.timezone || 'UTC';
                
                // Toggle schedule options based on enabled state
                toggleScheduleOptions();
                
                // Update display based on schedule type
                const intervalSettings = document.getElementById('intervalSettings');
                const timeSettings = document.getElementById('timeSettings');
                
                if (settings.type === 'interval') {
                    intervalSettings.style.display = 'block';
                    timeSettings.style.display = 'none';
                } else {
                    intervalSettings.style.display = 'none';
                    timeSettings.style.display = 'block';
                }
                
                await loadScheduledTasks();
            } catch (error) {
                console.error('Error loading schedule settings:', error);
            }
        }

        // Handle schedule form submission
        document.getElementById('scheduleForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            console.log("Schedule form submitted");
            
            const intervalValue = document.getElementById('intervalMinutes').value;
            
            const formData = {
                enabled: document.getElementById('scheduleEnabled').checked,
                type: document.getElementById('scheduleType').value,
                interval_minutes: intervalValue ? parseInt(intervalValue) : 0,
                daily_time: document.getElementById('dailyTime').value,
                timezone: document.getElementById('timezone').value,
                sleep_window: parseInt(document.getElementById('sleepWindow').value)
            };
            
            console.log("Sending schedule data:", formData);

            try {
                const response = await fetch('/api/schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log("Schedule update response:", result);
                
                // Don't reload settings, just update UI based on response
                if (result.schedule) {
                    document.getElementById('scheduleEnabled').checked = result.schedule.enabled;
                    document.getElementById('scheduleType').value = result.schedule.type;
                    if (result.schedule.interval_minutes !== undefined) {
                        document.getElementById('intervalMinutes').value = result.schedule.interval_minutes;
                    }
                    if (result.schedule.daily_time) {
                        document.getElementById('dailyTime').value = result.schedule.daily_time;
                    }
                    document.getElementById('timezone').value = result.schedule.timezone || 'UTC';
                    
                    // Update display based on schedule type
                    const intervalSettings = document.getElementById('intervalSettings');
                    const timeSettings = document.getElementById('timeSettings');
                    
                    if (result.schedule.type === 'interval') {
                        intervalSettings.style.display = 'block';
                        timeSettings.style.display = 'none';
                    } else {
                        intervalSettings.style.display = 'none';
                        timeSettings.style.display = 'block';
                    }
                }
                
                alert('Schedule settings saved successfully');
            } catch (error) {
                console.error('Error saving schedule settings:', error);
                alert('Error saving schedule settings: ' + error.message);
            }
        });

        // Load schedule settings when page loads
        document.addEventListener('DOMContentLoaded', loadScheduleSettings);

        // Separate function for timezone loading
        async function loadTimezones() {
            console.log("Starting timezone load...");  // Debug log
            const select = document.getElementById('timezone');
            
            try {
                console.log("Fetching /api/timezones...");  // Debug log
                const response = await fetch('/api/timezones');
                console.log("Response status:", response.status);  // Debug log
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const timezones = await response.json();
                console.log("Received timezones:", timezones);  // Debug log
                
                if (!Array.isArray(timezones)) {
                    throw new Error('Received invalid timezone data');
                }
                
                // Clear existing options
                select.innerHTML = '';
                
                // Add all timezone options
                timezones.forEach(tz => {
                    console.log("Adding timezone:", tz);  // Debug log
                    const option = document.createElement('option');
                    option.value = tz;
                    option.textContent = tz;
                    select.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading timezones:', error);
                select.innerHTML = '<option value="UTC">UTC (Error loading timezones)</option>';
            }
        }

        // Make sure loadTimezones is called when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM loaded, calling loadTimezones");  // Debug log
            loadTimezones();
        });

        function toggleScheduleOptions() {
            const enabled = document.getElementById('scheduleEnabled').checked;
            const scheduleOptions = document.getElementById('scheduleOptions');
            
            if (enabled) {
                scheduleOptions.classList.remove('disabled');
                scheduleOptions.querySelectorAll('input, select').forEach(element => {
                    element.disabled = false;
                });
            } else {
                scheduleOptions.classList.add('disabled');
                scheduleOptions.querySelectorAll('input, select').forEach(element => {
                    element.disabled = true;
                });
            }
        }

        document.getElementById('resetButton').addEventListener('click', async function() {
            showModal('Resetting application...');
            
            try {
                const response = await fetch('/api/reset', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    // Wait for the application to restart
                    setTimeout(async function checkStatus() {
                        try {
                            const statusResponse = await fetch('/api/status');
                            if (statusResponse.ok) {
                                hideModal();
                                location.reload();
                            } else {
                                setTimeout(checkStatus, 1000);
                            }
                        } catch {
                            setTimeout(checkStatus, 1000);
                        }
                    }, 1000);
                }
            } catch (error) {
                console.error('Reset failed:', error);
                showModal('Reset failed: ' + error);
            }
        });

        async function loadScheduledTasks() {
            try {
                const response = await fetch('/api/schedule/jobs');
                const jobs = await response.json();
                const container = document.getElementById('scheduledTasks');
                container.innerHTML = '';
                
                jobs.forEach(job => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'scheduled-task';
                    
                    // Format date with timezone consideration
                    const options = {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    };
                    
                    const nextRun = job.next_run_time ? 
                        new Date(job.next_run_time * 1000).toLocaleString('en-US', options) : 
                        'Not scheduled';

                    taskEl.innerHTML = `
                        <div>${job.name}</div>
                        <div>${nextRun}</div>
                        <div>${job.interval || 'Once'}</div>
                        <div>
                            <button class="delete-task-btn" data-job-id="${job.id}">×</button>
                        </div>
                    `;
                    container.appendChild(taskEl);
                });

                // Add delete handlers
                document.querySelectorAll('.delete-task-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const jobId = e.target.dataset.jobId;
                        try {
                            const response = await fetch(`/api/schedule/jobs/${jobId}`, { 
                                method: 'DELETE' 
                            });
                            
                            if (!response.ok) {
                                const error = await response.json();
                                throw new Error(error.error);
                            }
                            
                            // Immediate refresh
                            await loadScheduledTasks();
                            
                        } catch (error) {
                            console.error('Error deleting task:', error);
                            alert(`Delete failed: ${error.message}`);
                        }
                    });
                });
            } catch (error) {
                console.error('Error loading scheduled tasks:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // ... existing code ...
            setInterval(loadScheduledTasks, 30000); // Refresh every 30 seconds
        });

        // Add event listener for sleep window changes
        document.getElementById('sleepWindow').addEventListener('change', async function() {
            try {
                const settings = {
                    sleep_window: parseInt(this.value)
                };
                
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(settings)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save sleep settings');
                }
                
                console.log('Sleep settings saved successfully');
            } catch (error) {
                console.error('Error saving sleep settings:', error);
                alert('Failed to save sleep settings');
            }
        });

        // Stock photo integration (Unsplash and Pixabay)
        let currentStockService = null;
        let selectedStockPhotos = new Set();
        
        function showUnsplashModal() {
            currentStockService = 'unsplash';
            document.getElementById('stockModalTitle').textContent = 'Search Unsplash Photos';
            document.getElementById('stockSearchInput').value = '';
            document.getElementById('stockPhotoResults').innerHTML = '';
            document.getElementById('stockPhotoModal').style.display = 'block';
        }
        
        function showPixabayModal() {
            currentStockService = 'pixabay';
            document.getElementById('stockModalTitle').textContent = 'Search Pixabay Photos';
            document.getElementById('stockSearchInput').value = '';
            document.getElementById('stockPhotoResults').innerHTML = '';
            document.getElementById('stockPhotoModal').style.display = 'block';
        }
        
        function hideStockPhotoModal() {
            document.getElementById('stockPhotoModal').style.display = 'none';
            selectedStockPhotos.clear();
        }
        
        async function searchStockPhotos() {
            const query = document.getElementById('stockSearchInput').value.trim();
            if (!query) {
                alert('Please enter a search term');
                return;
            }
            
            const resultsContainer = document.getElementById('stockPhotoResults');
            const loader = document.getElementById('stockPhotoLoader');
            
            resultsContainer.innerHTML = '';
            loader.style.display = 'block';
            selectedStockPhotos.clear();
            
            try {
                let endpoint = '';
                let requestData = { query: query, count: 10 };
                
                if (currentStockService === 'unsplash') {
                    endpoint = '/api/unsplash/preview';
                } else if (currentStockService === 'pixabay') {
                    endpoint = '/api/pixabay/preview';
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch photos');
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                if (!data.results || data.results.length === 0) {
                    resultsContainer.innerHTML = '<p>No photos found. Try a different search term.</p>';
                    return;
                }
                
                // Display the photos
                data.results.forEach(photo => {
                    const photoDiv = document.createElement('div');
                    photoDiv.className = 'stock-photo-item';
                    photoDiv.style.position = 'relative';
                    photoDiv.style.cursor = 'pointer';
                    photoDiv.style.border = '2px solid transparent';
                    photoDiv.style.borderRadius = '4px';
                    photoDiv.style.overflow = 'hidden';
                    
                    const img = document.createElement('img');
                    img.src = photo.preview_url;
                    img.alt = photo.description || photo.alt_description || 'Stock photo';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    
                    photoDiv.appendChild(img);
                    photoDiv.dataset.photoId = photo.id;
                    photoDiv.dataset.photoData = JSON.stringify(photo);
                    
                    photoDiv.addEventListener('click', function() {
                        if (selectedStockPhotos.has(photo.id)) {
                            selectedStockPhotos.delete(photo.id);
                            this.style.border = '2px solid transparent';
                        } else {
                            selectedStockPhotos.add(photo.id);
                            this.style.border = '2px solid #4CAF50';
                        }
                        
                        // Enable/disable the Add Selected button
                        document.getElementById('addSelectedStockPhotosBtn').disabled = selectedStockPhotos.size === 0;
                    });
                    
                    resultsContainer.appendChild(photoDiv);
                });
                
            } catch (error) {
                console.error('Error searching photos:', error);
                resultsContainer.innerHTML = `<p>Error: ${error.message}</p>`;
            } finally {
                loader.style.display = 'none';
            }
        }
        
        async function addSelectedStockPhotos() {
            if (selectedStockPhotos.size === 0) {
                alert('Please select at least one photo');
                return;
            }
            
            const resultsContainer = document.getElementById('stockPhotoResults');
            const selectedPhotosData = [];
            
            // Collect all selected photos data
            selectedStockPhotos.forEach(photoId => {
                const photoDiv = resultsContainer.querySelector(`[data-photo-id="${photoId}"]`);
                if (photoDiv) {
                    try {
                        const photoData = JSON.parse(photoDiv.dataset.photoData);
                        selectedPhotosData.push(photoData);
                    } catch (e) {
                        console.error('Error parsing photo data:', e);
                    }
                }
            });
            
            if (selectedPhotosData.length === 0) {
                alert('Error collecting selected photos data');
                return;
            }
            
            // Show loading modal
            showModal('Adding photos to your gallery...');
            
            try {
                let endpoint = '';
                
                if (currentStockService === 'unsplash') {
                    endpoint = '/api/unsplash/add-to-frame';
                } else if (currentStockService === 'pixabay') {
                    endpoint = '/api/pixabay/add-to-frame';
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        photos_data: selectedPhotosData,
                        photos: selectedPhotosData, // For Pixabay API compatibility
                        frame_id: 'default' // Use default frame or get from a dropdown if you have multiple frames
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to add photos');
                }
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Success - reload the gallery
                hideStockPhotoModal();
                loadPhotos();
                alert('Photos added successfully!');
                
            } catch (error) {
                console.error('Error adding photos:', error);
                alert(`Error adding photos: ${error.message}`);
            } finally {
                hideModal();
            }
        }
        
        // Add event listener for Enter key in search input
        document.getElementById('stockSearchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchStockPhotos();
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadPhotos();
        });
    </script>
</body>
</html>
